# Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит куча камней. 
# Игроки ходят по очереди, первый ход делает Петя. 
# За один ход игрок может добавить в кучу один или четыре камня либо увеличить количество камней в куче в пять раз. 
# Например, имея кучу из 15 камней, за один ход можно получить кучу из 16, 19 или 75 камней. 
# У каждого игрока, чтобы делать ходы, есть неограниченное количество камней. И
# гра завершается в тот момент, когда количество камней в куче становится не менее 68.

# Победителем считается игрок, сделавший последний ход, то есть первым получивший кучу, в которой будет 68 или больше камней. 
# В начальный момент в куче было S камней; 1 ≤ S ≤ 67.

# Будем говорить, что игрок имеет выигрышную стратегию, если он может выиграть при любых ходах противника. 
# Описать стратегию игрока  — значит, описать, какой ход он должен сделать в любой ситуации, которая ему может встретиться при различной игре противника. 
# В описание выигрышной стратегии не следует включать ходы играющего по этой стратегии игрока, не являющиеся для него безусловно выигрышными, 
# то есть не являющиеся выигрышными независимо от игры противника.

# 19) Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети. Укажите минимальное значение S, когда такая ситуация возможна.

# 20) Найдите два таких значения S, при которых у Пети есть выигрышная стратегия, причём одновременно выполняются два условия:
# —  Петя не может выиграть за один ход;
# —  Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.

# 21) Найдите минимальное значение S, при котором одновременно выполняются два условия:
# —  у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети;
# —  у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.


def v1(a):
    return ((a+1>=68) or (a*5>=68) or (a+4>=68)) and (a<=67)
def p1(a):
    return v1(a+1) and v1(a+4) and v1(a*5) and not(v1(a))
def v2(a):
    return p1(a+1) or p1(a*5) or p1(a+4)
def p2(a):
    return (v2(a+1) or v2(a+4) or v2(a*5)) and (v1(a+1) or v2(a+1)) and (v1(a+4) or v2(a+4)) and (v1(a*5) or v2(a*5))
def wr_p1(a):
    return (v1(a+1) or v1(a+4) or v1(a*5)) and not(v1(a))


a=[]
for s in range(1, 68):
    if wr_p1(s) == 1:
        a.append(s)
print(a, min(a))

b=[]
for s in range(1, 68):
    if v2(s) == 1:
        b.append(s)
print(b)

c=[]
for s in range(1, 68):
    if p2(s) == 1:
        c.append(s)
print(c, min(c))
